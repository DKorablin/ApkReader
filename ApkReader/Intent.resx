<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="android.dock_home" xml:space="preserve">
    <value>Boolean that can be supplied as meta-data with a dock activity, to indicate that the dock should take over the home key when it is active.</value>
  </data>
  <data name="android.intent.action.ACTION_POWER_CONNECTED" xml:space="preserve">
    <value>Broadcast Action: External power has been connected to the device. This is intended for applications that wish to register specifically to this notification. Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to stay active to receive this notification. This action can be used to implement actions that wait until power is available to trigger.</value>
  </data>
  <data name="android.intent.action.ACTION_POWER_DISCONNECTED" xml:space="preserve">
    <value>Broadcast Action: External power has been removed from the device. This is intended for applications that wish to register specifically to this notification. Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to stay active to receive this notification. This action can be used to implement actions that wait until power is available to trigger.</value>
  </data>
  <data name="android.intent.action.ACTION_SHUTDOWN" xml:space="preserve">
    <value>Broadcast Action: Device is shutting down. This is broadcast when the device is being shut down (completely turned off, not sleeping). Once the broadcast is complete, the final shutdown will proceed and all unsaved data lost. Apps will not normally need to handle this, since the foreground activity will be paused as well.

As of Build.VERSION_CODES#P this broadcast is only sent to receivers registered through Context#registerReceiver(BroadcastReceiver, IntentFilter).

May include the following extras:

    EXTRA_SHUTDOWN_USERSPACE_ONLY a boolean that is set to true if this shutdown is only for userspace processes. If not set, assumed to be false.</value>
  </data>
  <data name="android.intent.action.AIRPLANE_MODE" xml:space="preserve">
    <value>Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or more radios have been turned off or on.</value>
  </data>
  <data name="android.intent.action.ALL_APPS" xml:space="preserve">
    <value>Activity Action: List all available applications.</value>
  </data>
  <data name="android.intent.action.ANSWER" xml:space="preserve">
    <value>Activity Action: Handle an incoming phone call.</value>
  </data>
  <data name="android.intent.action.APPLICATION_PREFERENCES" xml:space="preserve">
    <value>An activity that provides a user interface for adjusting application preferences. Optional but recommended settings for all applications which have settings.</value>
  </data>
  <data name="android.intent.action.APPLICATION_RESTRICTIONS_CHANGED" xml:space="preserve">
    <value>Broadcast Action: Sent after application restrictions are changed.</value>
  </data>
  <data name="android.intent.action.APP_ERROR" xml:space="preserve">
    <value>Activity Action: The user pressed the "Report" button in the crash/ANR dialog. This intent is delivered to the package which installed the application, usually Google Play.</value>
  </data>
  <data name="android.intent.action.ASSIST" xml:space="preserve">
    <value>Activity Action: Perform assist action.

Input: EXTRA_ASSIST_PACKAGE, EXTRA_ASSIST_CONTEXT, can provide additional optional contextual information about where the user was when they requested the assist; EXTRA_REFERRER may be set with additional referrer information.</value>
  </data>
  <data name="android.intent.action.ATTACH_DATA" xml:space="preserve">
    <value>Used to indicate that some piece of data should be attached to some other place. For example, image data could be attached to a contact. It is up to the recipient to decide where the data should be attached; the intent does not specify the ultimate destination.

Input: getData() is URI of data to be attached.</value>
  </data>
  <data name="android.intent.action.BATTERY_CHANGED" xml:space="preserve">
    <value>Broadcast Action: This is a sticky broadcast containing the charging state, level, and other information about the battery. See BatteryManager for documentation on the contents of the Intent.</value>
  </data>
  <data name="android.intent.action.BATTERY_LOW" xml:space="preserve">
    <value>Broadcast Action: Indicates low battery condition on the device. This broadcast corresponds to the "Low battery warning" system dialog.</value>
  </data>
  <data name="android.intent.action.BATTERY_OKAY" xml:space="preserve">
    <value>Broadcast Action: Indicates the battery is now okay after being low. This will be sent after ACTION_BATTERY_LOW once the battery has gone back up to an okay state.</value>
  </data>
  <data name="android.intent.action.BOOT_COMPLETED" xml:space="preserve">
    <value>Broadcast Action: This is broadcast once, after the user has finished booting. It can be used to perform application-specific initialization, such as installing alarms. You must hold the Manifest.permission.RECEIVE_BOOT_COMPLETED permission in order to receive this broadcast.

This broadcast is sent at boot by all devices (both with and without direct boot support). Upon receipt of this broadcast, the user is unlocked and both device-protected and credential-protected storage can accessed safely.

If you need to run while the user is still locked (before they've entered their lock pattern or PIN for the first time), you can listen for the ACTION_LOCKED_BOOT_COMPLETED broadcast.</value>
  </data>
  <data name="android.intent.action.BUG_REPORT" xml:space="preserve">
    <value>Activity Action: Show activity for reporting a bug.</value>
  </data>
  <data name="android.intent.action.CALL" xml:space="preserve">
    <value>Activity Action: Perform a call to someone specified by the data.

Input: If nothing, an empty dialer is started; else getData() is URI of a phone number to be dialed or a tel: URI of an explicit phone number.

Output: nothing.

Note: there will be restrictions on which applications can initiate a call; most applications should use the ACTION_DIAL.

Note: this Intent cannot be used to call emergency numbers. Applications can dial emergency numbers using ACTION_DIAL, however.

Note: if you app targets M and above and declares as using the Manifest.permission.CALL_PHONE permission which is not granted, then attempting to use this action will result in a SecurityException.</value>
  </data>
  <data name="android.intent.action.CALL_BUTTON" xml:space="preserve">
    <value>Activity Action: The user pressed the "call" button to go to the dialer or other appropriate UI for placing a call.</value>
  </data>
  <data name="android.intent.action.CAMERA_BUTTON" xml:space="preserve">
    <value>Broadcast Action: The "Camera Button" was pressed. Includes a single extra field, EXTRA_KEY_EVENT, containing the key event that caused the broadcast.</value>
  </data>
  <data name="android.intent.action.CARRIER_SETUP" xml:space="preserve">
    <value>Activity Action: Main entry point for carrier setup apps.

Carrier apps that provide an implementation for this action may be invoked to configure carrier service and typically require carrier privileges to fulfill their duties.</value>
  </data>
  <data name="android.intent.action.CHOOSER" xml:space="preserve">
    <value>Activity Action: Display an activity chooser, allowing the user to pick what they want to before proceeding. This can be used as an alternative to the standard activity picker that is displayed by the system when you try to start an activity with multiple possible matches, with these differences in behavior:

    You can specify the title that will appear in the activity chooser.
    The user does not have the option to make one of the matching activities a preferred activity, and all possible activities will always be shown even if one of them is currently marked as the preferred activity. 

This action should be used when the user will naturally expect to select an activity in order to proceed. An example if when not to use it is when the user clicks on a "mailto:" link. They would naturally expect to go directly to their mail app, so startActivity() should be called directly: it will either launch the current preferred app, or put up a dialog allowing the user to pick an app to use and optionally marking that as preferred.

In contrast, if the user is selecting a menu item to send a picture they are viewing to someone else, there are many different things they may want to do at this point: send it through e-mail, upload it to a web service, etc. In this case the CHOOSER action should be used, to always present to the user a list of the things they can do, with a nice title given by the caller such as "Send this photo with:".

If you need to grant URI permissions through a chooser, you must specify the permissions to be granted on the ACTION_CHOOSER Intent in addition to the EXTRA_INTENT inside. This means using setClipData(ClipData) to specify the URIs to be granted as well as FLAG_GRANT_READ_URI_PERMISSION and/or FLAG_GRANT_WRITE_URI_PERMISSION as appropriate.

As a convenience, an Intent of this form can be created with the createChooser(Intent, CharSequence) function.

Input: No data should be specified. get*Extra must have a EXTRA_INTENT field containing the Intent being executed, and can optionally have a EXTRA_TITLE field containing the title text to display in the chooser.

Output: Depends on the protocol of EXTRA_INTENT.</value>
  </data>
  <data name="android.intent.action.CLOSE_SYSTEM_DIALOGS" xml:space="preserve">
    <value>Broadcast Action: This is broadcast when a user action should request a temporary system dialog to dismiss. Some examples of temporary system dialogs are the notification window-shade and the recent tasks dialog.</value>
  </data>
  <data name="android.intent.action.CONFIGURATION_CHANGED" xml:space="preserve">
    <value>Broadcast Action: The current device Configuration (orientation, locale, etc) has changed. When such a change happens, the UIs (view hierarchy) will need to be rebuilt based on this new information; for the most part, applications don't need to worry about this, because the system will take care of stopping and restarting the application to make sure it sees the new changes. Some system code that can not be restarted will need to watch for this action and handle it appropriately.</value>
  </data>
  <data name="android.intent.action.CREATE_DOCUMENT" xml:space="preserve">
    <value>Activity Action: Allow the user to create a new document. When invoked, the system will display the various DocumentsProvider instances installed on the device, letting the user navigate through them. The returned document may be a newly created document with no content, or it may be an existing document with the requested MIME type.

Each document is represented as a content:// URI backed by a DocumentsProvider, which can be opened as a stream with ContentResolver#openFileDescriptor(Uri, String), or queried for DocumentsContract.Document metadata.

Callers must indicate the concrete MIME type of the document being created by setting setType(java.lang.String). This MIME type cannot be changed after the document is created.

Callers can provide an initial display name through EXTRA_TITLE, but the user may change this value before creating the file.

Callers must include CATEGORY_OPENABLE in the Intent to obtain URIs that can be opened with ContentResolver#openFileDescriptor(Uri, String).

Callers can set a document URI through DocumentsContract#EXTRA_INITIAL_URI to indicate the initial location of documents navigator. System will do its best to launch the navigator in the specified document if it's a folder, or the folder that contains the specified document if not.

Output: The URI of the item that was created. This must be a content:// URI so that any receiver can access it.</value>
  </data>
  <data name="android.intent.action.CREATE_REMINDER" xml:space="preserve">
    <value>Activity Action: Creates a reminder.

Input: EXTRA_TITLE The title of the reminder that will be shown to the user. EXTRA_TEXT The reminder text that will be shown to the user. The intent should at least specify a title or a text. EXTRA_TIME The time when the reminder will be shown to the user. The time is specified in milliseconds since the Epoch (optional).</value>
  </data>
  <data name="android.intent.action.CREATE_SHORTCUT" xml:space="preserve">
    <value>Activity Action: Creates a shortcut.

Input: Nothing.

Output: An Intent representing the ShortcutInfo result.

For compatibility with older versions of android the intent may also contain three extras: SHORTCUT_INTENT (value: Intent), SHORTCUT_NAME (value: String), and SHORTCUT_ICON (value: Bitmap) or SHORTCUT_ICON_RESOURCE (value: ShortcutIconResource).</value>
  </data>
  <data name="android.intent.action.DATE_CHANGED" xml:space="preserve">
    <value>Broadcast Action: The date has changed.</value>
  </data>
  <data name="android.intent.action.DEFINE" xml:space="preserve">
    <value>Activity Action: Define the meaning of the selected word(s).

Input: getCharSequence(EXTRA_TEXT) is the text to define.</value>
  </data>
  <data name="android.intent.action.DELETE" xml:space="preserve">
    <value>Activity Action: Delete the given data from its container.

Input: getData() is URI of data to be deleted.</value>
  </data>
  <data name="android.intent.action.DIAL" xml:space="preserve">
    <value>Activity Action: Dial a number as specified by the data. This shows a UI with the number being dialed, allowing the user to explicitly initiate the call.

Input: If nothing, an empty dialer is started; else getData() is URI of a phone number to be dialed or a tel: URI of an explicit phone number.</value>
  </data>
  <data name="android.intent.action.DOCK_EVENT" xml:space="preserve">
    <value>Broadcast Action: A sticky broadcast for changes in the physical docking state of the device.

The intent will have the following extra values:

    EXTRA_DOCK_STATE - the current dock state, indicating which dock the device is physically in.

This is intended for monitoring the current physical dock state. See UiModeManager for the normal API dealing with dock mode changes.</value>
  </data>
  <data name="android.intent.action.DREAMING_STARTED" xml:space="preserve">
    <value>Broadcast Action: Sent after the system starts dreaming.</value>
  </data>
  <data name="android.intent.action.DREAMING_STOPPED" xml:space="preserve">
    <value>Broadcast Action: Sent after the system stops dreaming.</value>
  </data>
  <data name="android.intent.action.EDIT" xml:space="preserve">
    <value>Activity Action: Provide explicit editable access to the given data.

Input: getData() is URI of data to be edited.</value>
  </data>
  <data name="android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE" xml:space="preserve">
    <value>Broadcast Action: Resources for a set of packages (which were previously unavailable) are currently available since the media on which they exist is available. The extra data EXTRA_CHANGED_PACKAGE_LIST contains a list of packages whose availability changed. The extra data EXTRA_CHANGED_UID_LIST contains a list of uids of packages whose availability changed. Note that the packages in this list do not receive this broadcast. The specified set of packages are now available on the system.

Includes the following extras:

    EXTRA_CHANGED_PACKAGE_LIST is the set of packages whose resources(were previously unavailable) are currently available. EXTRA_CHANGED_UID_LIST is the set of uids of the packages whose resources(were previously unavailable) are currently available.</value>
  </data>
  <data name="android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE" xml:space="preserve">
    <value>Broadcast Action: Resources for a set of packages are currently unavailable since the media on which they exist is unavailable. The extra data EXTRA_CHANGED_PACKAGE_LIST contains a list of packages whose availability changed. The extra data EXTRA_CHANGED_UID_LIST contains a list of uids of packages whose availability changed. The specified set of packages can no longer be launched and are practically unavailable on the system.

Inclues the following extras:

    EXTRA_CHANGED_PACKAGE_LIST is the set of packages whose resources are no longer available. EXTRA_CHANGED_UID_LIST is the set of packages whose resources are no longer available.</value>
  </data>
  <data name="android.intent.action.FACTORY_TEST" xml:space="preserve">
    <value>Activity Action: Main entry point for factory tests. Only used when the device is booting in factory test node. The implementing package must be installed in the system image.</value>
  </data>
  <data name="android.intent.action.GET_CONTENT" xml:space="preserve">
    <value>Activity Action: Allow the user to select a particular kind of data and return it. This is different than ACTION_PICK in that here we just say what kind of data is desired, not a URI of existing data from which the user can pick. An ACTION_GET_CONTENT could allow the user to create the data as it runs (for example taking a picture or recording a sound), let them browse over the web and download the desired data, etc.

There are two main ways to use this action: if you want a specific kind of data, such as a person contact, you set the MIME type to the kind of data you want and launch it with Context#startActivity(Intent). The system will then launch the best application to select that kind of data for you.

You may also be interested in any of a set of types of content the user can pick. For example, an e-mail application that wants to allow the user to add an attachment to an e-mail message can use this action to bring up a list of all of the types of content the user can attach.

In this case, you should wrap the GET_CONTENT intent with a chooser (through createChooser(Intent, CharSequence)), which will give the proper interface for the user to pick how to send your data and allow you to specify a prompt indicating what they are doing. You will usually specify a broad MIME type (such as image/* or */*), resulting in a broad range of content types the user can select from.

When using such a broad GET_CONTENT action, it is often desirable to only pick from data that can be represented as a stream. This is accomplished by requiring the CATEGORY_OPENABLE in the Intent.

Callers can optionally specify EXTRA_LOCAL_ONLY to request that the launched content chooser only returns results representing data that is locally available on the device. For example, if this extra is set to true then an image picker should not show any pictures that are available from a remote server but not already on the local device (thus requiring they be downloaded when opened).

If the caller can handle multiple returned items (the user performing multiple selection), then it can specify EXTRA_ALLOW_MULTIPLE to indicate this.

Input: getType() is the desired MIME type to retrieve. Note that no URI is supplied in the intent, as there are no constraints on where the returned data originally comes from. You may also include the CATEGORY_OPENABLE if you can only accept data that can be opened as a stream. You may use EXTRA_LOCAL_ONLY to limit content selection to local data. You may use EXTRA_ALLOW_MULTIPLE to allow the user to select multiple items.

Output: The URI of the item that was picked. This must be a content: URI so that any receiver can access it.</value>
  </data>
  <data name="android.intent.action.GET_RESTRICTION_ENTRIES" xml:space="preserve">
    <value>Broadcast to a specific application to query any supported restrictions to impose on restricted users. The broadcast intent contains an extra EXTRA_RESTRICTIONS_BUNDLE with the currently persisted restrictions as a Bundle of key/value pairs. The value types can be Boolean, String or String[] depending on the restriction type.

The response should contain an extra EXTRA_RESTRICTIONS_LIST, which is of type ArrayList&lt;RestrictionEntry&gt;. It can also contain an extra EXTRA_RESTRICTIONS_INTENT, which is of type Intent. The activity specified by that intent will be launched for a result which must contain one of the extras EXTRA_RESTRICTIONS_LIST or EXTRA_RESTRICTIONS_BUNDLE. The keys and values of the returned restrictions will be persisted.</value>
  </data>
  <data name="android.intent.action.GTALK_CONNECTED" xml:space="preserve">
    <value>Broadcast Action: A GTalk connection has been established.</value>
  </data>
  <data name="android.intent.action.GTALK_DISCONNECTED" xml:space="preserve">
    <value>Broadcast Action: A GTalk connection has been disconnected.</value>
  </data>
  <data name="android.intent.action.HEADSET_PLUG" xml:space="preserve">
    <value>Broadcast Action: Wired Headset plugged in or unplugged. Same as AudioManager.ACTION_HEADSET_PLUG, to be consulted for value and documentation.

If the minimum SDK version of your application is Build.VERSION_CODES.LOLLIPOP, it is recommended to refer to the AudioManager constant in your receiver registration code instead.</value>
  </data>
  <data name="android.intent.action.INPUT_METHOD_CHANGED" xml:space="preserve">
    <value>Broadcast Action: An input method has been changed.</value>
  </data>
  <data name="android.intent.action.INSERT" xml:space="preserve">
    <value>Activity Action: Insert an empty item into the given container.

Input: getData() is URI of the directory (vnd.android.cursor.dir/*) in which to place the data.

Output: URI of the new data that was created.</value>
  </data>
  <data name="android.intent.action.INSERT_OR_EDIT" xml:space="preserve">
    <value>Activity Action: Pick an existing item, or insert a new item, and then edit it.

Input: getType() is the desired MIME type of the item to create or edit. The extras can contain type specific data to pass through to the editing/creating activity.

Output: The URI of the item that was picked. This must be a content: URI so that any receiver can access it.</value>
  </data>
  <data name="android.intent.action.INSTALL_FAILURE" xml:space="preserve">
    <value>Activity Action: Activity to handle split installation failures.

Splits may be installed dynamically. This happens when an Activity is launched, but the split that contains the application isn't installed. When a split is installed in this manner, the containing package usually doesn't know this is happening. However, if an error occurs during installation, the containing package can define a single activity handling this action to deal with such failures.

The activity handling this action must be in the base package.

Input: EXTRA_INTENT the original intent that started split installation. EXTRA_SPLIT_NAME the name of the split that failed to be installed.</value>
  </data>
  <data name="android.intent.action.LOCALE_CHANGED" xml:space="preserve">
    <value>Broadcast Action: The current device's locale has changed.</value>
  </data>
  <data name="android.intent.action.LOCKED_BOOT_COMPLETED" xml:space="preserve">
    <value>Broadcast Action: This is broadcast once, after the user has finished booting, but while still in the "locked" state. It can be used to perform application-specific initialization, such as installing alarms. You must hold the Manifest.permission.RECEIVE_BOOT_COMPLETED permission in order to receive this broadcast.

This broadcast is sent immediately at boot by all devices (regardless of direct boot support) running Build.VERSION_CODES.N or higher. Upon receipt of this broadcast, the user is still locked and only device-protected storage can be accessed safely. If you want to access credential-protected storage, you need to wait for the user to be unlocked (typically by entering their lock pattern or PIN for the first time), after which the ACTION_USER_UNLOCKED and ACTION_BOOT_COMPLETED broadcasts are sent.

To receive this broadcast, your receiver component must be marked as being ComponentInfo#directBootAware.</value>
  </data>
  <data name="android.intent.action.MAIN" xml:space="preserve">
    <value>Activity Action: Start as a main entry point, does not expect to receive data.</value>
  </data>
  <data name="android.intent.action.MANAGED_PROFILE_ADDED" xml:space="preserve">
    <value>Broadcast sent to the primary user when an associated managed profile is added (the profile was created and is ready to be used). Carries an extra EXTRA_USER that specifies the UserHandle of the profile that was added. Only applications (for example Launchers) that need to display merged content across both primary and managed profiles need to worry about this broadcast. This is only sent to registered receivers, not manifest receivers.</value>
  </data>
  <data name="android.intent.action.MANAGED_PROFILE_AVAILABLE" xml:space="preserve">
    <value>Broadcast sent to the primary user when an associated managed profile has become available. Currently this includes when the user disables quiet mode for the profile. Carries an extra EXTRA_USER that specifies the UserHandle of the profile. When quiet mode is changed, this broadcast will carry a boolean extra EXTRA_QUIET_MODE indicating the new state of quiet mode. This is only sent to registered receivers, not manifest receivers.</value>
  </data>
  <data name="android.intent.action.MANAGED_PROFILE_REMOVED" xml:space="preserve">
    <value>Broadcast sent to the primary user when an associated managed profile is removed. Carries an extra EXTRA_USER that specifies the UserHandle of the profile that was removed. Only applications (for example Launchers) that need to display merged content across both primary and managed profiles need to worry about this broadcast. This is only sent to registered receivers, not manifest receivers.</value>
  </data>
  <data name="android.intent.action.MANAGED_PROFILE_UNAVAILABLE" xml:space="preserve">
    <value>Broadcast sent to the primary user when an associated managed profile has become unavailable. Currently this includes when the user enables quiet mode for the profile. Carries an extra EXTRA_USER that specifies the UserHandle of the profile. When quiet mode is changed, this broadcast will carry a boolean extra EXTRA_QUIET_MODE indicating the new state of quiet mode. This is only sent to registered receivers, not manifest receivers.</value>
  </data>
  <data name="android.intent.action.MANAGED_PROFILE_UNLOCKED" xml:space="preserve">
    <value>Broadcast sent to the primary user when the credential-encrypted private storage for an associated managed profile is unlocked. Carries an extra EXTRA_USER that specifies the UserHandle of the profile that was unlocked. Only applications (for example Launchers) that need to display merged content across both primary and managed profiles need to worry about this broadcast. This is only sent to registered receivers, not manifest receivers.</value>
  </data>
  <data name="android.intent.action.MANAGE_NETWORK_USAGE" xml:space="preserve">
    <value>Activity Action: Show settings for managing network data usage of a specific application. Applications should define an activity that offers options to control data usage.</value>
  </data>
  <data name="android.intent.action.MANAGE_PACKAGE_STORAGE" xml:space="preserve">
    <value>Broadcast Action: Indicates low memory condition notification acknowledged by user and package management should be started. This is triggered by the user from the ACTION_DEVICE_STORAGE_LOW notification.</value>
  </data>
  <data name="android.intent.action.MEDIA_BAD_REMOVAL" xml:space="preserve">
    <value>Broadcast Action: External media was removed from SD card slot, but mount point was not unmounted. The path to the mount point for the removed media is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_BUTTON" xml:space="preserve">
    <value>Broadcast Action: The "Media Button" was pressed. Includes a single extra field, EXTRA_KEY_EVENT, containing the key event that caused the broadcast.</value>
  </data>
  <data name="android.intent.action.MEDIA_CHECKING" xml:space="preserve">
    <value>Broadcast Action: External media is present, and being disk-checked The path to the mount point for the checking media is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_EJECT" xml:space="preserve">
    <value>Broadcast Action: User has expressed the desire to remove the external storage media. Applications should close all files they have open within the mount point when they receive this intent. The path to the mount point for the media to be ejected is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_MOUNTED" xml:space="preserve">
    <value>Broadcast Action: External media is present and mounted at its mount point. The path to the mount point for the mounted media is contained in the Intent.mData field. The Intent contains an extra with name "read-only" and Boolean value to indicate if the media was mounted read only.</value>
  </data>
  <data name="android.intent.action.MEDIA_NOFS" xml:space="preserve">
    <value>Broadcast Action: External media is present, but is using an incompatible fs (or is blank) The path to the mount point for the checking media is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_REMOVED" xml:space="preserve">
    <value>Broadcast Action: External media has been removed. The path to the mount point for the removed media is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_SCANNER_FINISHED" xml:space="preserve">
    <value>Broadcast Action: The media scanner has finished scanning a directory. The path to the scanned directory is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_SCANNER_SCAN_FILE" xml:space="preserve">
    <value>Broadcast Action: Request the media scanner to scan a file and add it to the media database.

The path to the file is contained in Intent#getData().</value>
  </data>
  <data name="android.intent.action.MEDIA_SCANNER_STARTED" xml:space="preserve">
    <value>Broadcast Action: The media scanner has started scanning a directory. The path to the directory being scanned is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_SHARED" xml:space="preserve">
    <value>Broadcast Action: External media is unmounted because it is being shared via USB mass storage. The path to the mount point for the shared media is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_UNMOUNTABLE" xml:space="preserve">
    <value>Broadcast Action: External media is present but cannot be mounted. The path to the mount point for the unmountable media is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MEDIA_UNMOUNTED" xml:space="preserve">
    <value>Broadcast Action: External media is present, but not mounted at its mount point. The path to the mount point for the unmounted media is contained in the Intent.mData field.</value>
  </data>
  <data name="android.intent.action.MY_PACKAGE_REPLACED" xml:space="preserve">
    <value>Broadcast Action: A new version of your application has been installed over an existing one. This is only sent to the application that was replaced. It does not contain any additional data; to receive it, just use an intent filter for this action.</value>
  </data>
  <data name="android.intent.action.MY_PACKAGE_SUSPENDED" xml:space="preserve">
    <value>Broadcast Action: Sent to a package that has been suspended by the system. This is sent whenever a package is put into a suspended state or any of its app extras change while in the suspended state.

Optionally includes the following extras:

    EXTRA_SUSPENDED_PACKAGE_EXTRAS which is a Bundle which will contain useful information for the app being suspended.</value>
  </data>
  <data name="android.intent.action.MY_PACKAGE_UNSUSPENDED" xml:space="preserve">
    <value>Broadcast Action: Sent to a package that has been unsuspended.</value>
  </data>
  <data name="android.intent.action.OPEN_DOCUMENT" xml:space="preserve">
    <value>Activity Action: Allow the user to select and return one or more existing documents. When invoked, the system will display the various DocumentsProvider instances installed on the device, letting the user interactively navigate through them. These documents include local media, such as photos and video, and documents provided by installed cloud storage providers.

Each document is represented as a content:// URI backed by a DocumentsProvider, which can be opened as a stream with ContentResolver#openFileDescriptor(Uri, String), or queried for DocumentsContract.Document metadata.

All selected documents are returned to the calling application with persistable read and write permission grants. If you want to maintain access to the documents across device reboots, you need to explicitly take the persistable permissions using ContentResolver#takePersistableUriPermission(Uri, int).

Callers must indicate the acceptable document MIME types through setType(java.lang.String). For example, to select photos, use image/*. If multiple disjoint MIME types are acceptable, define them in EXTRA_MIME_TYPES and setType(java.lang.String) to */*.

If the caller can handle multiple returned items (the user performing multiple selection), then you can specify EXTRA_ALLOW_MULTIPLE to indicate this.

Callers must include CATEGORY_OPENABLE in the Intent to obtain URIs that can be opened with ContentResolver#openFileDescriptor(Uri, String).

Callers can set a document URI through DocumentsContract#EXTRA_INITIAL_URI to indicate the initial location of documents navigator. System will do its best to launch the navigator in the specified document if it's a folder, or the folder that contains the specified document if not.

Output: The URI of the item that was picked, returned in getData(). This must be a content:// URI so that any receiver can access it. If multiple documents were selected, they are returned in getClipData().</value>
  </data>
  <data name="android.intent.action.OPEN_DOCUMENT_TREE" xml:space="preserve">
    <value>Activity Action: Allow the user to pick a directory subtree. When invoked, the system will display the various DocumentsProvider instances installed on the device, letting the user navigate through them. Apps can fully manage documents within the returned directory.

To gain access to descendant (child, grandchild, etc) documents, use DocumentsContract#buildDocumentUriUsingTree(Uri, String) and DocumentsContract#buildChildDocumentsUriUsingTree(Uri, String) with the returned URI.

Callers can set a document URI through DocumentsContract#EXTRA_INITIAL_URI to indicate the initial location of documents navigator. System will do its best to launch the navigator in the specified document if it's a folder, or the folder that contains the specified document if not.

Output: The URI representing the selected directory tree.</value>
  </data>
  <data name="android.intent.action.PACKAGES_SUSPENDED" xml:space="preserve">
    <value>Broadcast Action: Packages have been suspended.

Includes the following extras:

    EXTRA_CHANGED_PACKAGE_LIST is the set of packages which have been suspended
    EXTRA_CHANGED_UID_LIST is the set of uids which have been suspended</value>
  </data>
  <data name="android.intent.action.PACKAGES_UNSUSPENDED" xml:space="preserve">
    <value>Broadcast Action: Packages have been unsuspended.

Includes the following extras:

    EXTRA_CHANGED_PACKAGE_LIST is the set of packages which have been unsuspended
    EXTRA_CHANGED_UID_LIST is the set of uids which have been unsuspended</value>
  </data>
  <data name="android.intent.action.PACKAGE_ADDED" xml:space="preserve">
    <value>Broadcast Action: A new application package has been installed on the device. The data contains the name of the package. Note that the newly installed package does not receive this broadcast.

May include the following extras:

    EXTRA_UID containing the integer uid assigned to the new package.
    EXTRA_REPLACING is set to true if this is following an ACTION_PACKAGE_REMOVED broadcast for the same package.</value>
  </data>
  <data name="android.intent.action.PACKAGE_CHANGED" xml:space="preserve">
    <value>Broadcast Action: An existing application package has been changed (for example, a component has been enabled or disabled). The data contains the name of the package.

    EXTRA_UID containing the integer uid assigned to the package.
    EXTRA_CHANGED_COMPONENT_NAME_LIST containing the class name of the changed components (or the package name itself).
    EXTRA_DONT_KILL_APP containing boolean field to override the default action of restarting the application.</value>
  </data>
  <data name="android.intent.action.PACKAGE_DATA_CLEARED" xml:space="preserve">
    <value>Broadcast Action: The user has cleared the data of a package. This should be preceded by ACTION_PACKAGE_RESTARTED, after which all of its persistent data is erased and this broadcast sent. Note that the cleared package does not receive this broadcast. The data contains the name of the package.

    EXTRA_UID containing the integer uid assigned to the package. If the package whose data was cleared is an uninstalled instant app, then the UID will be -1. The platform keeps some meta-data associated with instant apps after they are uninstalled.
    EXTRA_PACKAGE_NAME containing the package name only if the cleared data was for an instant app.</value>
  </data>
  <data name="android.intent.action.PACKAGE_FIRST_LAUNCH" xml:space="preserve">
    <value>Broadcast Action: Sent to the installer package of an application when that application is first launched (that is the first time it is moved out of the stopped state). The data contains the name of the package.

When the application is first launched, the application itself doesn't receive this broadcast.</value>
  </data>
  <data name="android.intent.action.PACKAGE_FULLY_REMOVED" xml:space="preserve">
    <value>Broadcast Action: An existing application package has been completely removed from the device. The data contains the name of the package. This is like ACTION_PACKAGE_REMOVED, but only set when EXTRA_DATA_REMOVED is true and EXTRA_REPLACING is false of that broadcast.

    EXTRA_UID containing the integer uid previously assigned to the package.</value>
  </data>
  <data name="android.intent.action.PACKAGE_NEEDS_VERIFICATION" xml:space="preserve">
    <value>Broadcast Action: Sent to the system package verifier when a package needs to be verified. The data contains the package URI.</value>
  </data>
  <data name="android.intent.action.PACKAGE_REMOVED" xml:space="preserve">
    <value>Broadcast Action: An existing application package has been removed from the device. The data contains the name of the package. The package that is being removed does not receive this Intent.

    EXTRA_UID containing the integer uid previously assigned to the package.
    EXTRA_DATA_REMOVED is set to true if the entire application -- data and code -- is being removed.
    EXTRA_REPLACING is set to true if this will be followed by an ACTION_PACKAGE_ADDED broadcast for the same package.</value>
  </data>
  <data name="android.intent.action.PACKAGE_REPLACED" xml:space="preserve">
    <value>Broadcast Action: A new version of an application package has been installed, replacing an existing version that was previously installed. The data contains the name of the package.

May include the following extras:

    EXTRA_UID containing the integer uid assigned to the new package.</value>
  </data>
  <data name="android.intent.action.PACKAGE_RESTARTED" xml:space="preserve">
    <value>Broadcast Action: The user has restarted a package, and all of its processes have been killed. All runtime state associated with it (processes, alarms, notifications, etc) should be removed. Note that the restarted package does not receive this broadcast. The data contains the name of the package.

    EXTRA_UID containing the integer uid assigned to the package.</value>
  </data>
  <data name="android.intent.action.PACKAGE_VERIFIED" xml:space="preserve">
    <value>Broadcast Action: Sent to the system package verifier when a package is verified. The data contains the package URI.</value>
  </data>
  <data name="android.intent.action.PASTE" xml:space="preserve">
    <value>Activity Action: Create a new item in the given container, initializing it from the current contents of the clipboard.

Input: getData() is URI of the directory (vnd.android.cursor.dir/*) in which to place the data.

Output: URI of the new data that was created.</value>
  </data>
  <data name="android.intent.action.PICK" xml:space="preserve">
    <value>Activity Action: Pick an item from the data, returning what was selected.

Input: getData() is URI containing a directory of data (vnd.android.cursor.dir/*) from which to pick an item.

Output: The URI of the item that was picked.</value>
  </data>
  <data name="android.intent.action.PICK_ACTIVITY" xml:space="preserve">
    <value>Activity Action: Pick an activity given an intent, returning the class selected.

Input: get*Extra field EXTRA_INTENT is an Intent used with PackageManager#queryIntentActivities to determine the set of activities from which to pick.

Output: Class name of the activity that was selected.</value>
  </data>
  <data name="android.intent.action.POWER_USAGE_SUMMARY" xml:space="preserve">
    <value>Activity Action: Show power usage information to the user.</value>
  </data>
  <data name="android.intent.action.PROCESS_TEXT" xml:space="preserve">
    <value>Activity Action: Process a piece of text.

Input: EXTRA_PROCESS_TEXT contains the text to be processed. EXTRA_PROCESS_TEXT_READONLY states if the resulting text will be read-only.

Output: EXTRA_PROCESS_TEXT contains the processed text.</value>
  </data>
  <data name="android.intent.action.PROVIDER_CHANGED" xml:space="preserve">
    <value>Broadcast Action: Some content providers have parts of their namespace where they publish new events or items that the user may be especially interested in. For these things, they may broadcast this action when the set of interesting items change. For example, GmailProvider sends this notification when the set of unread mail in the inbox changes.

The data of the intent identifies which part of which provider changed. When queried through the content resolver, the data URI will return the data set in question.

The intent will have the following extra values:

    count - The number of items in the data set. This is the same as the number of items in the cursor returned by querying the data URI.

This intent will be sent at boot (if the count is non-zero) and when the data set changes. It is possible for the data set to change without the count changing (for example, if a new unread message arrives in the same sync operation in which a message is archived). The phone should still ring/vibrate/etc as normal in this case.</value>
  </data>
  <data name="android.intent.action.QUICK_CLOCK" xml:space="preserve">
    <value>Sent when the user taps on the clock widget in the system's "quick settings" area.</value>
  </data>
  <data name="android.intent.action.QUICK_VIEW" xml:space="preserve">
    <value>Activity Action: Quick view the data. Launches a quick viewer for a URI or a list of URIs.

Activities handling this intent action should handle the vast majority of MIME types rather than only specific ones.

Quick viewers must render the quick view image locally, and must not send file content outside current device.

Input: getData() is a mandatory content URI of the item to preview. getClipData() contains an optional list of content URIs if there is more than one item to preview. EXTRA_INDEX is an optional index of the URI in the clip data to show first. EXTRA_QUICK_VIEW_FEATURES is an optional extra indicating the features that can be shown in the quick view UI.</value>
  </data>
  <data name="android.intent.action.REBOOT" xml:space="preserve">
    <value>Broadcast Action: Have the device reboot. This is only for use by system code.</value>
  </data>
  <data name="android.intent.action.RUN" xml:space="preserve">
    <value>Activity Action: Run the data, whatever that means.

Input: ? (Note: this is currently specific to the test harness.)</value>
  </data>
  <data name="android.intent.action.SCREEN_OFF" xml:space="preserve">
    <value>Broadcast Action: Sent when the device goes to sleep and becomes non-interactive.

For historical reasons, the name of this broadcast action refers to the power state of the screen but it is actually sent in response to changes in the overall interactive state of the device.

This broadcast is sent when the device becomes non-interactive which may have nothing to do with the screen turning off. To determine the actual state of the screen, use Display.getState().

See PowerManager.isInteractive() for details.
You cannot receive this through components declared in manifests, only by explicitly registering for it with Context#registerReceiver(BroadcastReceiver, IntentFilter).</value>
  </data>
  <data name="android.intent.action.SCREEN_ON" xml:space="preserve">
    <value>Broadcast Action: Sent when the device wakes up and becomes interactive.

For historical reasons, the name of this broadcast action refers to the power state of the screen but it is actually sent in response to changes in the overall interactive state of the device.

This broadcast is sent when the device becomes interactive which may have nothing to do with the screen turning on. To determine the actual state of the screen, use Display.getState().

See PowerManager.isInteractive() for details.
You cannot receive this through components declared in manifests, only by explicitly registering for it with Context#registerReceiver(BroadcastReceiver, IntentFilter).</value>
  </data>
  <data name="android.intent.action.SEARCH" xml:space="preserve">
    <value>Activity Action: Perform a search.

Input: getStringExtra(SearchManager.QUERY) is the text to search for. If empty, simply enter your search results Activity with the search UI activated.</value>
  </data>
  <data name="android.intent.action.SEARCH_LONG_PRESS" xml:space="preserve">
    <value>Activity Action: Start action associated with long pressing on the search key.</value>
  </data>
  <data name="android.intent.action.SEND" xml:space="preserve">
    <value>Activity Action: Deliver some data to someone else. Who the data is being delivered to is not specified; it is up to the receiver of this action to ask the user where the data should be sent.

When launching a SEND intent, you should usually wrap it in a chooser (through createChooser(Intent, CharSequence)), which will give the proper interface for the user to pick how to send your data and allow you to specify a prompt indicating what they are doing.

Input: getType() is the MIME type of the data being sent. get*Extra can have either a EXTRA_TEXT or EXTRA_STREAM field, containing the data to be sent. If using EXTRA_TEXT, the MIME type should be "text/plain"; otherwise it should be the MIME type of the data in EXTRA_STREAM. Use */* if the MIME type is unknown (this will only allow senders that can handle generic data streams). If using EXTRA_TEXT, you can also optionally supply EXTRA_HTML_TEXT for clients to retrieve your text with HTML formatting.

As of Build.VERSION_CODES.JELLY_BEAN, the data being sent can be supplied through setClipData(android.content.ClipData). This allows you to use FLAG_GRANT_READ_URI_PERMISSION when sharing content: URIs and other advanced features of ClipData. If using this approach, you still must supply the same data through the EXTRA_TEXT or EXTRA_STREAM fields described below for compatibility with old applications. If you don't set a ClipData, it will be copied there for you when calling Context#startActivity(Intent).

Starting from Build.VERSION_CODES.O, if CATEGORY_TYPED_OPENABLE is passed, then the Uris passed in either EXTRA_STREAM or via setClipData(android.content.ClipData) may be openable only as asset typed files using ContentResolver#openTypedAssetFileDescriptor(Uri, String, Bundle).

Optional standard extras, which may be interpreted by some recipients as appropriate, are: EXTRA_EMAIL, EXTRA_CC, EXTRA_BCC, EXTRA_SUBJECT.</value>
  </data>
  <data name="android.intent.action.SENDTO" xml:space="preserve">
    <value>Activity Action: Send a message to someone specified by the data.

Input: getData() is URI describing the target.</value>
  </data>
  <data name="android.intent.action.SEND_MULTIPLE" xml:space="preserve">
    <value>Activity Action: Deliver multiple data to someone else.

Like ACTION_SEND, except the data is multiple.

Input: getType() is the MIME type of the data being sent. get*ArrayListExtra can have either a EXTRA_TEXT or EXTRA_STREAM field, containing the data to be sent. If using EXTRA_TEXT, you can also optionally supply EXTRA_HTML_TEXT for clients to retrieve your text with HTML formatting.

Multiple types are supported, and receivers should handle mixed types whenever possible. The right way for the receiver to check them is to use the content resolver on each URI. The intent sender should try to put the most concrete mime type in the intent type, but it can fall back to &lt;type&gt;/* or */* as needed.

e.g. if you are sending image/jpg and image/jpg, the intent's type can be image/jpg, but if you are sending image/jpg and image/png, then the intent's type should be image/*.

As of Build.VERSION_CODES.JELLY_BEAN, the data being sent can be supplied through setClipData(android.content.ClipData). This allows you to use FLAG_GRANT_READ_URI_PERMISSION when sharing content: URIs and other advanced features of ClipData. If using this approach, you still must supply the same data through the EXTRA_TEXT or EXTRA_STREAM fields described below for compatibility with old applications. If you don't set a ClipData, it will be copied there for you when calling Context#startActivity(Intent).

Starting from Build.VERSION_CODES.O, if CATEGORY_TYPED_OPENABLE is passed, then the Uris passed in either EXTRA_STREAM or via setClipData(android.content.ClipData) may be openable only as asset typed files using ContentResolver#openTypedAssetFileDescriptor(Uri, String, Bundle).

Optional standard extras, which may be interpreted by some recipients as appropriate, are: EXTRA_EMAIL, EXTRA_CC, EXTRA_BCC, EXTRA_SUBJECT.</value>
  </data>
  <data name="android.intent.action.SET_WALLPAPER" xml:space="preserve">
    <value>Activity Action: Show settings for choosing wallpaper.</value>
  </data>
  <data name="android.intent.action.SHOW_APP_INFO" xml:space="preserve">
    <value>Activity Action: Launch an activity showing the app information. For applications which install other applications (such as app stores), it is recommended to handle this action for providing the app information to the user.

Input: EXTRA_PACKAGE_NAME specifies the package whose information needs to be displayed.</value>
  </data>
  <data name="android.intent.action.SYNC" xml:space="preserve">
    <value>Activity Action: Perform a data synchronization.

Input: ?

Output: ?</value>
  </data>
  <data name="android.intent.action.SYSTEM_TUTORIAL" xml:space="preserve">
    <value>Activity Action: Start the platform-defined tutorial

Input: getStringExtra(SearchManager.QUERY) is the text to search for. If empty, simply enter your search results Activity with the search UI activated.</value>
  </data>
  <data name="android.intent.action.TIMEZONE_CHANGED" xml:space="preserve">
    <value>Broadcast Action: The timezone has changed. The intent will have the following extra values:

    EXTRA_TIMEZONE - The java.util.TimeZone.getID() value identifying the new time zone.</value>
  </data>
  <data name="android.intent.action.TIME_SET" xml:space="preserve">
    <value>Broadcast Action: The time was set.</value>
  </data>
  <data name="android.intent.action.TIME_TICK" xml:space="preserve">
    <value>Broadcast Action: The current time has changed. Sent every minute. You cannot receive this through components declared in manifests, only by explicitly registering for it with Context#registerReceiver(BroadcastReceiver, IntentFilter).</value>
  </data>
  <data name="android.intent.action.TRANSLATE" xml:space="preserve">
    <value>Activity Action: Perform text translation.

Input: getCharSequence(EXTRA_TEXT) is the text to translate.</value>
  </data>
  <data name="android.intent.action.UID_REMOVED" xml:space="preserve">
    <value>Broadcast Action: A user ID has been removed from the system. The user ID number is stored in the extra data under EXTRA_UID.</value>
  </data>
  <data name="android.intent.action.USER_BACKGROUND" xml:space="preserve">
    <value>Sent when a user switch is happening, causing the process's user to be sent to the background. This is only sent to receivers registered through Context#registerReceiver(BroadcastReceiver, IntentFilter). It is sent to the user that is going to the background. This is sent as a foreground broadcast, since it is part of a visible user interaction; be as quick as possible when handling it.</value>
  </data>
  <data name="android.intent.action.USER_FOREGROUND" xml:space="preserve">
    <value>Sent when a user switch is happening, causing the process's user to be brought to the foreground. This is only sent to receivers registered through Context#registerReceiver(BroadcastReceiver, IntentFilter). It is sent to the user that is going to the foreground. This is sent as a foreground broadcast, since it is part of a visible user interaction; be as quick as possible when handling it.</value>
  </data>
  <data name="android.intent.action.USER_INITIALIZE" xml:space="preserve">
    <value>Sent the first time a user is starting, to allow system apps to perform one time initialization. (This will not be seen by third party applications because a newly initialized user does not have any third party applications installed for it.) This is sent early in starting the user, around the time the home app is started, before ACTION_BOOT_COMPLETED is sent. This is sent as a foreground broadcast, since it is part of a visible user interaction; be as quick as possible when handling it.</value>
  </data>
  <data name="android.intent.action.USER_PRESENT" xml:space="preserve">
    <value>Broadcast Action: Sent when the user is present after device wakes up (e.g when the keyguard is gone).</value>
  </data>
  <data name="android.intent.action.USER_UNLOCKED" xml:space="preserve">
    <value>Broadcast Action: Sent when the credential-encrypted private storage has become unlocked for the target user. This is only sent to registered receivers, not manifest receivers.</value>
  </data>
  <data name="android.intent.action.VIEW" xml:space="preserve">
    <value>Activity Action: Display the data to the user. This is the most common action performed on data -- it is the generic action you can use on a piece of data to get the most reasonable thing to occur. For example, when used on a contacts entry it will view the entry; when used on a mailto: URI it will bring up a compose window filled with the information supplied by the URI; when used with a tel: URI it will invoke the dialer.</value>
  </data>
  <data name="android.intent.action.VIEW_LOCUS" xml:space="preserve">
    <value>Activity Action: Display an activity state associated with an unique LocusId.

For example, a chat app could use the context to resume a conversation between 2 users.

Input: EXTRA_LOCUS_ID specifies the unique identifier of the locus in the app domain. Should be stable across reboots and backup / restore.</value>
  </data>
  <data name="android.intent.action.VIEW_PERMISSION_USAGE" xml:space="preserve">
    <value>Activity action: Launch UI to show information about the usage of a given permission. This action would be handled by apps that want to show details about how and why given permission is being used.

Important:You must protect the activity that handles this action with the START_VIEW_PERMISSION_USAGE permission to ensure that only the system can launch this activity. The system will not launch activities that are not properly protected.

Input: android.intent.extra.PERMISSION_NAME specifies the permission for which the launched UI would be targeted.</value>
  </data>
  <data name="android.intent.action.VOICE_COMMAND" xml:space="preserve">
    <value>Activity Action: Start Voice Command.</value>
  </data>
  <data name="android.intent.action.WEB_SEARCH" xml:space="preserve">
    <value>Activity Action: Perform a web search.

Input: getStringExtra(SearchManager.QUERY) is the text to search for. If it is a url starts with http or https, the site will be opened. If it is plain text, Google search will be applied.</value>
  </data>
  <data name="android.intent.category.ACCESSIBILITY_SHORTCUT_TARGET" xml:space="preserve">
    <value>The accessibility shortcut is a global gesture for users with disabilities to trigger an important for them accessibility feature to help developers determine whether they want to make their activity a shortcut target.

An activity of interest to users with accessibility needs may request to be the target of the accessibility shortcut. It handles intent ACTION_MAIN with this category, which will be dispatched by the system when the user activates the shortcut when it is configured to point at this target.

An activity declared itself to be a target of the shortcut in AndroidManifest.xml. It must also do two things:

        Specify that it handles the android.intent.action.MAIN Intent with category android.intent.category.ACCESSIBILITY_SHORTCUT_TARGET. 
        Provide a meta-data entry android.accessibilityshortcut.target in the manifest when declaring the activity.</value>
  </data>
  <data name="android.intent.category.ALTERNATIVE" xml:space="preserve">
    <value>Set if the activity should be considered as an alternative action to the data the user is currently viewing. See also CATEGORY_SELECTED_ALTERNATIVE for an alternative action that applies to the selection in a list of items.

Supporting this category means that you would like your activity to be displayed in the set of alternative things the user can do, usually as part of the current activity's options menu. You will usually want to include a specific label in the &lt;intent-filter&gt; of this action describing to the user what it does.

The action of IntentFilter with this category is important in that it describes the specific action the target will perform. This generally should not be a generic action (such as ACTION_VIEW, but rather a specific name such as "com.android.camera.action.CROP. Only one alternative of any particular action will be shown to the user, so using a specific action like this makes sure that your alternative will be displayed while also allowing other applications to provide their own overrides of that particular action.</value>
  </data>
  <data name="android.intent.category.APP_BROWSER" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the browser application. The activity should be able to browse the Internet.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_CALCULATOR" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the calculator application. The activity should be able to perform standard arithmetic operations.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_CALENDAR" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the calendar application. The activity should be able to view and manipulate calendar entries.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_CONTACTS" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the contacts application. The activity should be able to view and manipulate address book entries.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_EMAIL" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the email application. The activity should be able to send and receive email.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_FILES" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the files application. The activity should be able to browse and manage files stored on the device.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_GALLERY" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the gallery application. The activity should be able to view and manipulate image and video files stored on the device.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_MAPS" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the maps application. The activity should be able to show the user's current location and surroundings.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_MARKET" xml:space="preserve">
    <value>This activity allows the user to browse and download new applications.</value>
  </data>
  <data name="android.intent.category.APP_MESSAGING" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the messaging application. The activity should be able to send and receive text messages.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.APP_MUSIC" xml:space="preserve">
    <value>Used with ACTION_MAIN to launch the music application. The activity should be able to play, browse, or manipulate music files stored on the device.

NOTE: This should not be used as the primary key of an Intent, since it will not result in the app launching with the correct action and category. Instead, use this with makeMainSelectorActivity(java.lang.String, java.lang.String) to generate a main Intent with this category in the selector.</value>
  </data>
  <data name="android.intent.category.BROWSABLE" xml:space="preserve">
    <value>Activities that can be safely invoked from a browser must support this category. For example, if the user is viewing a web page or an e-mail and clicks on a link in the text, the Intent generated execute that link will require the BROWSABLE category, so that only activities supporting this category will be considered as possible actions. By supporting this category, you are promising that there is nothing damaging (without user intervention) that can happen by invoking any matching Intent.</value>
  </data>
  <data name="android.intent.category.CAR_DOCK" xml:space="preserve">
    <value>An activity to run when device is inserted into a car dock. Used with ACTION_MAIN to launch an activity. For more information, see UiModeManager.</value>
  </data>
  <data name="android.intent.category.CAR_MODE" xml:space="preserve">
    <value>Used to indicate that the activity can be used in a car environment.</value>
  </data>
  <data name="android.intent.category.DEFAULT" xml:space="preserve">
    <value>Set if the activity should be an option for the default action (center press) to perform on a piece of data. Setting this will hide from the user any activities without it set when performing an action on some data. Note that this is normally -not- set in the Intent when initiating an action -- it is for use in intent filters specified in packages.</value>
  </data>
  <data name="android.intent.category.DESK_DOCK" xml:space="preserve">
    <value>An activity to run when device is inserted into a car dock. Used with ACTION_MAIN to launch an activity. For more information, see UiModeManager.</value>
  </data>
  <data name="android.intent.category.DEVELOPMENT_PREFERENCE" xml:space="preserve">
    <value>This activity is a development preference panel.</value>
  </data>
  <data name="android.intent.category.EMBED" xml:space="preserve">
    <value>Capable of running inside a parent activity container.</value>
  </data>
  <data name="android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST" xml:space="preserve">
    <value>To be used as code under test for framework instrumentation tests.</value>
  </data>
  <data name="android.intent.category.HE_DESK_DOCK" xml:space="preserve">
    <value>An activity to run when device is inserted into a digital (high end) dock. Used with ACTION_MAIN to launch an activity. For more information, see UiModeManager.</value>
  </data>
  <data name="android.intent.category.HOME" xml:space="preserve">
    <value>This is the home activity, that is the first activity that is displayed when the device boots.</value>
  </data>
  <data name="android.intent.category.INFO" xml:space="preserve">
    <value>Provides information about the package it is in; typically used if a package does not contain a CATEGORY_LAUNCHER to provide a front-door to the user without having to be shown in the all apps list.</value>
  </data>
  <data name="android.intent.category.LAUNCHER" xml:space="preserve">
    <value>Should be displayed in the top-level launcher.</value>
  </data>
  <data name="android.intent.category.LEANBACK_LAUNCHER" xml:space="preserve">
    <value>Indicates an activity optimized for Leanback mode, and that should be displayed in the Leanback launcher.</value>
  </data>
  <data name="android.intent.category.LE_DESK_DOCK" xml:space="preserve">
    <value>An activity to run when device is inserted into a analog (low end) dock. Used with ACTION_MAIN to launch an activity. For more information, see UiModeManager.</value>
  </data>
  <data name="android.intent.category.MONKEY" xml:space="preserve">
    <value>This activity may be exercised by the monkey or other automated test tools.</value>
  </data>
  <data name="android.intent.category.OPENABLE" xml:space="preserve">
    <value>Used to indicate that an intent only wants URIs that can be opened with ContentResolver#openFileDescriptor(Uri, String). Openable URIs must support at least the columns defined in OpenableColumns when queried.</value>
  </data>
  <data name="android.intent.category.PREFERENCE" xml:space="preserve">
    <value>This activity is a preference panel.</value>
  </data>
  <data name="android.intent.category.SAMPLE_CODE" xml:space="preserve">
    <value>To be used as a sample code example (not part of the normal user experience).</value>
  </data>
  <data name="android.intent.category.SECONDARY_HOME" xml:space="preserve">
    <value>The home activity shown on secondary displays that support showing home activities.</value>
  </data>
  <data name="android.intent.category.SELECTED_ALTERNATIVE" xml:space="preserve">
    <value>Set if the activity should be considered as an alternative selection action to the data the user has currently selected. This is like CATEGORY_ALTERNATIVE, but is used in activities showing a list of items from which the user can select, giving them alternatives to the default action that will be performed on it.</value>
  </data>
  <data name="android.intent.category.TAB" xml:space="preserve">
    <value>Intended to be used as a tab inside of a containing TabActivity.</value>
  </data>
  <data name="android.intent.category.TEST" xml:space="preserve">
    <value>To be used as a test (not part of the normal user experience).</value>
  </data>
  <data name="android.intent.category.TYPED_OPENABLE" xml:space="preserve">
    <value>Used to indicate that an intent filter can accept files which are not necessarily openable by ContentResolver#openFileDescriptor(Uri, String), but at least streamable via ContentResolver#openTypedAssetFileDescriptor(Uri, String, Bundle) using one of the stream types exposed via ContentResolver#getStreamTypes(Uri, String).</value>
  </data>
  <data name="android.intent.category.UNIT_TEST" xml:space="preserve">
    <value>To be used as a unit test (run through the Test Harness).</value>
  </data>
  <data name="android.intent.category.VOICE" xml:space="preserve">
    <value>Categories for activities that can participate in voice interaction. An activity that supports this category must be prepared to run with no UI shown at all (though in some case it may have a UI shown), and rely on VoiceInteractor to interact with the user.</value>
  </data>
  <data name="android.intent.category.VR_HOME" xml:space="preserve">
    <value>An activity to use for the launcher when the device is placed in a VR Headset viewer. Used with ACTION_MAIN to launch an activity. For more information, see UiModeManager.</value>
  </data>
  <data name="android.intent.extra.ALARM_COUNT" xml:space="preserve">
    <value>Used as an int extra field in AlarmManager intents to tell the application being invoked how many pending alarms are being delievered with the intent. For one-shot alarms this will always be 1. For recurring alarms, this might be greater than 1 if the device was asleep or powered off at the time an earlier alarm would have been delivered.</value>
  </data>
  <data name="android.intent.extra.ALLOW_MULTIPLE" xml:space="preserve">
    <value>Extra used to indicate that an intent can allow the user to select and return multiple items. This is a boolean extra; the default is false. If true, an implementation is allowed to present the user with a UI where they can pick multiple items that are all returned to the caller. When this happens, they should be returned as the getClipData() part of the result Intent.</value>
  </data>
  <data name="android.intent.extra.ALTERNATE_INTENTS" xml:space="preserve">
    <value>An Intent[] describing additional, alternate choices you would like shown with ACTION_CHOOSER.

An app may be capable of providing several different payload types to complete a user's intended action. For example, an app invoking ACTION_SEND to share photos with another app may use EXTRA_ALTERNATE_INTENTS to have the chooser transparently offer several different supported sending mechanisms for sharing, such as the actual "image/*" photo data or a hosted link where the photos can be viewed.

The intent present in EXTRA_INTENT will be treated as the first/primary/preferred intent in the set. Additional intents specified in this extra are ordered; by default intents that appear earlier in the array will be preferred over intents that appear later in the array as matches for the same target component. To alter this preference, a calling app may also supply EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER.</value>
  </data>
  <data name="android.intent.extra.ASSIST_CONTEXT" xml:space="preserve">
    <value>An optional field on ACTION_ASSIST and containing additional contextual information supplied by the current foreground app at the time of the assist request. This is a Bundle of additional data.</value>
  </data>
  <data name="android.intent.extra.ASSIST_INPUT_DEVICE_ID" xml:space="preserve">
    <value>An optional field on ACTION_ASSIST containing the InputDevice id that was used to invoke the assist.</value>
  </data>
  <data name="android.intent.extra.ASSIST_INPUT_HINT_KEYBOARD" xml:space="preserve">
    <value>An optional field on ACTION_ASSIST suggesting that the user will likely use a keyboard as the primary input device for assistance.</value>
  </data>
  <data name="android.intent.extra.ASSIST_PACKAGE" xml:space="preserve">
    <value>An optional field on ACTION_ASSIST containing the name of the current foreground application package at the time the assist was invoked.</value>
  </data>
  <data name="android.intent.extra.ASSIST_UID" xml:space="preserve">
    <value>An optional field on ACTION_ASSIST containing the uid of the current foreground application package at the time the assist was invoked.</value>
  </data>
  <data name="android.intent.extra.AUTO_LAUNCH_SINGLE_CHOICE" xml:space="preserve">
    <value>Used as a boolean extra field in ACTION_CHOOSER intents to specify whether to show the chooser or not when there is only one application available to choose from.</value>
  </data>
  <data name="android.intent.extra.BCC" xml:space="preserve">
    <value>A String[] holding e-mail addresses that should be blind carbon copied.</value>
  </data>
  <data name="android.intent.extra.BUG_REPORT" xml:space="preserve">
    <value>Used as a parcelable extra field in ACTION_APP_ERROR, containing the bug report.</value>
  </data>
  <data name="android.intent.extra.CC" xml:space="preserve">
    <value>A String[] holding e-mail addresses that should be carbon copied.</value>
  </data>
  <data name="android.intent.extra.changed_component_name_list" xml:space="preserve">
    <value>This field is part of ACTION_PACKAGE_CHANGED, and contains a string array of all of the components that have changed. If the state of the overall package has changed, then it will contain an entry with the package name itself.</value>
  </data>
  <data name="android.intent.extra.changed_package_list" xml:space="preserve">
    <value>This field is part of ACTION_EXTERNAL_APPLICATIONS_AVAILABLE, ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE, ACTION_PACKAGES_SUSPENDED, ACTION_PACKAGES_UNSUSPENDED and contains a string array of all of the components that have changed.</value>
  </data>
  <data name="android.intent.extra.changed_uid_list" xml:space="preserve">
    <value>This field is part of ACTION_EXTERNAL_APPLICATIONS_AVAILABLE, ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE and contains an integer array of uids of all of the components that have changed.</value>
  </data>
  <data name="android.intent.extra.CHOOSER_REFINEMENT_INTENT_SENDER" xml:space="preserve">
    <value>An IntentSender for an Activity that will be invoked when the user makes a selection from the chooser activity presented by ACTION_CHOOSER.

An app preparing an action for another app to complete may wish to allow the user to disambiguate between several options for completing the action based on the chosen target or otherwise refine the action before it is invoked.

When sent, this IntentSender may be filled in with the following extras:

    EXTRA_INTENT The first intent that matched the user's chosen target
    EXTRA_ALTERNATE_INTENTS Any additional intents that also matched the user's chosen target beyond the first
    EXTRA_RESULT_RECEIVER A ResultReceiver that the refinement activity should fill in and send once the disambiguation is complete</value>
  </data>
  <data name="android.intent.extra.CHOOSER_TARGETS" xml:space="preserve">
    <value>A ChooserTarget[] for ACTION_CHOOSER describing additional high-priority deep-link targets for the chooser to present to the user.

Targets provided in this way will be presented inline with all other targets provided by services from other apps. They will be prioritized before other service targets, but after those targets provided by sources that the user has manually pinned to the front.</value>
  </data>
  <data name="android.intent.extra.CHOSEN_COMPONENT" xml:space="preserve">
    <value>The ComponentName chosen by the user to complete an action.</value>
  </data>
  <data name="android.intent.extra.CHOSEN_COMPONENT_INTENT_SENDER" xml:space="preserve">
    <value>An IntentSender that will be notified if a user successfully chooses a target component to handle an action in an ACTION_CHOOSER activity. The IntentSender will have the extra EXTRA_CHOSEN_COMPONENT appended to it containing the ComponentName of the chosen component.

In some situations this callback may never come, for example if the user abandons the chooser, switches to another task or any number of other reasons. Apps should not be written assuming that this callback will always occur.</value>
  </data>
  <data name="android.intent.extra.COMPONENT_NAME" xml:space="preserve">
    <value>Intent extra: A ComponentName value.</value>
  </data>
  <data name="android.intent.extra.CONTENT_ANNOTATIONS" xml:space="preserve">
    <value>An ArrayList of String annotations describing content for ACTION_CHOOSER.

If EXTRA_CONTENT_ANNOTATIONS is present in an intent used to start a ACTION_CHOOSER activity, the first three annotations will be used to rank apps.

Annotations should describe the major components or topics of the content. It is up to apps initiating ACTION_CHOOSER to learn and add annotations. Annotations should be learned in advance, e.g., when creating or saving content, to avoid increasing latency to start ACTION_CHOOSER. Names of customized annotations should not contain the colon character. Performance on customized annotations can suffer, if they are rarely used for ACTION_CHOOSER in the past 14 days. Therefore, it is recommended to use the following annotations when applicable.

    "product" represents that the topic of the content is mainly about products, e.g., health &amp; beauty, and office supplies.
    "emotion" represents that the topic of the content is mainly about emotions, e.g., happy, and sad.
    "person" represents that the topic of the content is mainly about persons, e.g., face, finger, standing, and walking.
    "child" represents that the topic of the content is mainly about children, e.g., child, and baby.
    "selfie" represents that the topic of the content is mainly about selfies.
    "crowd" represents that the topic of the content is mainly about crowds.
    "party" represents that the topic of the content is mainly about parties.
    "animal" represent that the topic of the content is mainly about animals.
    "plant" represents that the topic of the content is mainly about plants, e.g., flowers.
    "vacation" represents that the topic of the content is mainly about vacations.
    "fashion" represents that the topic of the content is mainly about fashion, e.g. sunglasses, jewelry, handbags and clothing.
    "material" represents that the topic of the content is mainly about materials, e.g., paper, and silk.
    "vehicle" represents that the topic of the content is mainly about vehicles, like cars, and boats.
    "document" represents that the topic of the content is mainly about documents, e.g. posters.
    "design" represents that the topic of the content is mainly about design, e.g. arts and designs of houses.
    "holiday" represents that the topic of the content is mainly about holidays, e.g., Christmas and Thanksgiving.</value>
  </data>
  <data name="android.intent.extra.CONTENT_QUERY" xml:space="preserve">
    <value>Optional CharSequence extra to provide a search query. The format of this query is dependent on the receiving application.

Applicable to Intent with actions:

    Intent#ACTION_GET_CONTENT
    Intent#ACTION_OPEN_DOCUMENT</value>
  </data>
  <data name="android.intent.extra.DATA_REMOVED" xml:space="preserve">
    <value>Used as a boolean extra field in ACTION_PACKAGE_REMOVED intents to indicate whether this represents a full uninstall (removing both the code and its data) or a partial uninstall (leaving its data, implying that this is an update).</value>
  </data>
  <data name="android.intent.extra.DOCK_STATE" xml:space="preserve">
    <value>Used as an int extra field in ACTION_DOCK_EVENT intents to request the dock state. Possible values are EXTRA_DOCK_STATE_UNDOCKED, EXTRA_DOCK_STATE_DESK, or EXTRA_DOCK_STATE_CAR, or EXTRA_DOCK_STATE_LE_DESK, or EXTRA_DOCK_STATE_HE_DESK.</value>
  </data>
  <data name="android.intent.extra.DONT_KILL_APP" xml:space="preserve">
    <value>Used as a boolean extra field in ACTION_PACKAGE_REMOVED or ACTION_PACKAGE_CHANGED intents to override the default action of restarting the application.</value>
  </data>
  <data name="android.intent.extra.DURATION_MILLIS" xml:space="preserve">
    <value>Intent extra: The number of milliseconds.

Type: long</value>
  </data>
  <data name="android.intent.extra.EMAIL" xml:space="preserve">
    <value>A String[] holding e-mail addresses that should be delivered to.</value>
  </data>
  <data name="android.intent.extra.EXCLUDE_COMPONENTS" xml:space="preserve">
    <value>A ComponentName describing components that should be filtered out and omitted from a list of components presented to the user.

When used with ACTION_CHOOSER, the chooser will omit any of the components in this array if it otherwise would have shown them. Useful for omitting specific targets from your own package or other apps from your organization if the idea of sending to those targets would be redundant with other app functionality. Filtered components will not be able to present targets from an associated ChooserTargetService.</value>
  </data>
  <data name="android.intent.extra.FROM_STORAGE" xml:space="preserve">
    <value>Extra that can be included on activity intents coming from the storage UI when it launches sub-activities to manage various types of storage. For example, it may use ACTION_VIEW with a "image/*" MIME type to have an app show the images on the device, and in that case also include this extra to tell the app it is coming from the storage UI so should help the user manage storage of this type.</value>
  </data>
  <data name="android.intent.extra.HTML_TEXT" xml:space="preserve">
    <value>A constant String that is associated with the Intent, used with ACTION_SEND to supply an alternative to EXTRA_TEXT as HTML formatted text. Note that you must also supply EXTRA_TEXT.</value>
  </data>
  <data name="android.intent.extra.INDEX" xml:space="preserve">
    <value>Optional index with semantics depending on the intent action.

The value must be an integer greater or equal to 0.</value>
  </data>
  <data name="android.intent.extra.INITIAL_INTENTS" xml:space="preserve">
    <value>A Parcelable[] of Intent or LabeledIntent objects as set with putExtra(java.lang.String, android.os.Parcelable[]) of additional activities to place a the front of the list of choices, when shown to the user with a ACTION_CHOOSER.</value>
  </data>
  <data name="android.intent.extra.INSTALLER_PACKAGE_NAME" xml:space="preserve">
    <value>Used as a string extra field with ACTION_INSTALL_PACKAGE to install a package. Specifies the installer package name; this package will receive the ACTION_APP_ERROR intent.</value>
  </data>
  <data name="android.intent.extra.INTENT" xml:space="preserve">
    <value>An Intent describing the choices you would like shown with ACTION_PICK_ACTIVITY or ACTION_CHOOSER.</value>
  </data>
  <data name="android.intent.extra.KEY_EVENT" xml:space="preserve">
    <value>A KeyEvent object containing the event that triggered the creation of the Intent it is in.</value>
  </data>
  <data name="android.intent.extra.LOCAL_ONLY" xml:space="preserve">
    <value>Extra used to indicate that an intent should only return data that is on the local device. This is a boolean extra; the default is false. If true, an implementation should only allow the user to select data that is already on the device, not requiring it be downloaded from a remote service when opened.</value>
  </data>
  <data name="android.intent.extra.LOCUS_ID" xml:space="preserve">
    <value>Intent extra: ID of the context used on ACTION_VIEW_LOCUS.

Type: LocusId</value>
  </data>
  <data name="android.intent.extra.MIME_TYPES" xml:space="preserve">
    <value>Extra used to communicate a set of acceptable MIME types. The type of the extra is String[]. Values may be a combination of concrete MIME types (such as "image/png") and/or partial MIME types (such as "audio/*").</value>
  </data>
  <data name="android.intent.extra.NOT_UNKNOWN_SOURCE" xml:space="preserve">
    <value>Used as a boolean extra field with ACTION_INSTALL_PACKAGE to install a package. Specifies that the application being installed should not be treated as coming from an unknown source, but as coming from the app invoking the Intent. For this to work you must start the installer with startActivityForResult().</value>
  </data>
  <data name="android.intent.extra.ORIGINATING_URI" xml:space="preserve">
    <value>Used as a URI extra field with ACTION_INSTALL_PACKAGE and ACTION_VIEW to indicate the URI from which the local APK in the Intent data field originated from.</value>
  </data>
  <data name="android.intent.extra.PACKAGE_NAME" xml:space="preserve">
    <value>Intent extra: An app package name.

Type: String</value>
  </data>
  <data name="android.intent.extra.PHONE_NUMBER" xml:space="preserve">
    <value>A String holding the phone number originally entered in ACTION_NEW_OUTGOING_CALL, or the actual number to call in a ACTION_CALL.</value>
  </data>
  <data name="android.intent.extra.PROCESS_TEXT" xml:space="preserve">
    <value>The name of the extra used to define the text to be processed, as a CharSequence. Note that this may be a styled CharSequence, so you must use Bundle#getCharSequence(String) to retrieve it.</value>
  </data>
  <data name="android.intent.extra.PROCESS_TEXT_READONLY" xml:space="preserve">
    <value>The name of the boolean extra used to define if the processed text will be used as read-only.</value>
  </data>
  <data name="android.intent.extra.QUICK_VIEW_FEATURES" xml:space="preserve">
    <value>An optional extra of String[] indicating which quick view features should be made available to the user in the quick view UI while handing a Intent#ACTION_QUICK_VIEW intent.
Enumeration of features here is not meant to restrict capabilities of the quick viewer. Quick viewer can implement features not listed below.
Features included at this time are: QuickViewConstants#FEATURE_VIEW, QuickViewConstants#FEATURE_EDIT, QuickViewConstants#FEATURE_DELETE, QuickViewConstants#FEATURE_DOWNLOAD, QuickViewConstants#FEATURE_SEND, QuickViewConstants#FEATURE_PRINT.

Requirements:
Quick viewer shouldn't show a feature if the feature is absent in EXTRA_QUICK_VIEW_FEATURES.
When EXTRA_QUICK_VIEW_FEATURES is not present, quick viewer should follow internal policies.
Presence of an feature in EXTRA_QUICK_VIEW_FEATURES, does not constitute a requirement that the feature be shown. Quick viewer may, according to its own policies, disable or hide features.</value>
  </data>
  <data name="android.intent.extra.QUIET_MODE" xml:space="preserve">
    <value>Optional boolean extra indicating whether quiet mode has been switched on or off. When a profile goes into quiet mode, all apps in the profile are killed and the profile user is stopped. Widgets originating from the profile are masked, and app launcher icons are grayed out.</value>
  </data>
  <data name="android.intent.extra.REFERRER" xml:space="preserve">
    <value>This extra can be used with any Intent used to launch an activity, supplying information about who is launching that activity. This field contains a Uri object, typically an http: or https: URI of the web site that the referral came from; it can also use the android-app: scheme to identify a native application that it came from.

To retrieve this value in a client, use Activity.getReferrer() instead of directly retrieving the extra. It is also valid for applications to instead supply EXTRA_REFERRER_NAME for cases where they can only create a string, not a Uri; the field here, if supplied, will always take precedence, however.</value>
  </data>
  <data name="android.intent.extra.REFERRER_NAME" xml:space="preserve">
    <value>Alternate version of EXTRA_REFERRER that supplies the URI as a String rather than a Uri object. Only for use in cases where Uri objects can not be created, in particular when Intent extras are supplied through the intent: or android-app: schemes.</value>
  </data>
  <data name="android.intent.extra.remote_intent_token" xml:space="preserve">
    <value>Used in the extra field in the remote intent. It's astring token passed with the remote intent.</value>
  </data>
  <data name="android.intent.extra.REPLACEMENT_EXTRAS" xml:space="preserve">
    <value>A Bundle forming a mapping of potential target package names to different extras Bundles to add to the default intent extras in EXTRA_INTENT when used with ACTION_CHOOSER. Each key should be a package name. The package need not be currently installed on the device.

An application may choose to provide alternate extras for the case where a user selects an activity from a predetermined set of target packages. If the activity the user selects from the chooser belongs to a package with its package name as a key in this bundle, the corresponding extras for that package will be merged with the extras already present in the intent at EXTRA_INTENT. If a replacement extra has the same key as an extra already present in the intent it will overwrite the extra from the intent.

Examples:

    An application may offer different EXTRA_TEXT to an application when sharing with it via ACTION_SEND, augmenting a link with additional query parameters for that target.
    An application may offer additional metadata for known targets of a given intent to pass along information only relevant to that target such as account or content identifiers already known to that application.</value>
  </data>
  <data name="android.intent.extra.REPLACING" xml:space="preserve">
    <value>Used as a boolean extra field in ACTION_PACKAGE_REMOVED intents to indicate that this is a replacement of the package, so this broadcast will immediately be followed by an add broadcast for a different version of the same package.</value>
  </data>
  <data name="android.intent.extra.restrictions_bundle" xml:space="preserve">
    <value>Extra sent in the intent to the BroadcastReceiver that handles ACTION_GET_RESTRICTION_ENTRIES. The type of the extra is a Bundle containing the restrictions as key/value pairs.</value>
  </data>
  <data name="android.intent.extra.restrictions_intent" xml:space="preserve">
    <value>Extra used in the response from a BroadcastReceiver that handles ACTION_GET_RESTRICTION_ENTRIES.</value>
  </data>
  <data name="android.intent.extra.restrictions_list" xml:space="preserve">
    <value>Extra used in the response from a BroadcastReceiver that handles ACTION_GET_RESTRICTION_ENTRIES. The type of the extra is ArrayList&lt;RestrictionEntry&gt;.</value>
  </data>
  <data name="android.intent.extra.RESULT_RECEIVER" xml:space="preserve">
    <value>A ResultReceiver used to return data back to the sender.

Used to complete an app-specific refinement for ACTION_CHOOSER.

If EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER is present in the intent used to start a ACTION_CHOOSER activity this extra will be filled in to that IntentSender and sent when the user selects a target component from the chooser. It is up to the recipient to send a result to this ResultReceiver to signal that disambiguation is complete and that the chooser should invoke the user's choice.

The disambiguator should provide a Bundle to the ResultReceiver with an intent assigned to the key EXTRA_INTENT. This supplied intent will be used by the chooser to match and fill in the final Intent or ChooserTarget before starting it. The supplied intent must match one of the intents from EXTRA_INTENT or EXTRA_ALTERNATE_INTENTS passed to EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER to be accepted.

The result code passed to the ResultReceiver should be Activity.RESULT_OK if the refinement succeeded and the supplied intent's target in the chooser should be started, or Activity.RESULT_CANCELED if the chooser should finish without starting a target.</value>
  </data>
  <data name="android.intent.extra.RETURN_RESULT" xml:space="preserve">
    <value>Used as a boolean extra field with ACTION_INSTALL_PACKAGE or ACTION_UNINSTALL_PACKAGE. Specifies that the installer UI should return to the application the result code of the install/uninstall. The returned result code will be Activity.RESULT_OK on success or Activity.RESULT_FIRST_USER on failure.</value>
  </data>
  <data name="android.intent.extra.shortcut.ID" xml:space="preserve">
    <value>Intent extra: ID of the shortcut used to send the share intent. Will be sent with ACTION_SEND.</value>
  </data>
  <data name="android.intent.extra.SHUTDOWN_USERSPACE_ONLY" xml:space="preserve">
    <value>Optional extra for ACTION_SHUTDOWN that allows the sender to qualify that this shutdown is only for the user space of the system, not a complete shutdown. When this is true, hardware devices can use this information to determine that they shouldn't do a complete shutdown of their device since this is not a complete shutdown down to the kernel, but only user space restarting. The default if not supplied is false.</value>
  </data>
  <data name="android.intent.extra.SPLIT_NAME" xml:space="preserve">
    <value>Intent extra: An app split name.

Type: String</value>
  </data>
  <data name="android.intent.extra.STREAM" xml:space="preserve">
    <value>A content: URI holding a stream of data associated with the Intent, used with ACTION_SEND to supply the data being sent.</value>
  </data>
  <data name="android.intent.extra.SUBJECT" xml:space="preserve">
    <value>A constant string holding the desired subject line of a message.</value>
  </data>
  <data name="android.intent.extra.SUSPENDED_PACKAGE_EXTRAS" xml:space="preserve">
    <value>Intent extra: A Bundle of extras for a package being suspended. Will be sent as an extra with ACTION_MY_PACKAGE_SUSPENDED.

The contents of this Bundle are a contract between the suspended app and the suspending app, i.e. any app with the permission android.permission.SUSPEND_APPS. This is meant to enable the suspended app to better handle the state of being suspended.</value>
  </data>
  <data name="android.intent.extra.TEMPLATE" xml:space="preserve">
    <value>The initial data to place in a newly created record. Use with ACTION_INSERT. The data here is a Map containing the same fields as would be given to the underlying ContentProvider.insert() call.</value>
  </data>
  <data name="android.intent.extra.TEXT" xml:space="preserve">
    <value>A constant CharSequence that is associated with the Intent, used with ACTION_SEND to supply the literal data to be sent. Note that this may be a styled CharSequence, so you must use Bundle#getCharSequence(String) to retrieve it.</value>
  </data>
  <data name="android.intent.extra.TIME" xml:space="preserve">
    <value>Optional extra specifying a time in milliseconds since the Epoch. The value must be non-negative.

Type: long</value>
  </data>
  <data name="android.intent.extra.TITLE" xml:space="preserve">
    <value>A CharSequence dialog title to provide to the user when used with a ACTION_CHOOSER.</value>
  </data>
  <data name="android.intent.extra.UID" xml:space="preserve">
    <value>Used as an int extra field in ACTION_UID_REMOVED intents to supply the uid the package had been assigned. Also an optional extra in ACTION_PACKAGE_REMOVED or ACTION_PACKAGE_CHANGED for the same purpose.</value>
  </data>
  <data name="android.intent.extra.USER" xml:space="preserve">
    <value>The UserHandle carried with intents.</value>
  </data>
  <data name="time-zone" xml:space="preserve">
    <value>Extra sent with ACTION_TIMEZONE_CHANGED specifying the new time zone of the device.

Type: String, the same as returned by TimeZone#getID() to identify time zones.</value>
  </data>
</root>